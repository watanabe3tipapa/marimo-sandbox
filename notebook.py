import marimo

__generated_with = "0.14.17"
app = marimo.App(width="medium")


@app.cell
def _():
    return


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""# こんな使い方ができますよ""")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r""" """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r""" """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    MarimoとJupyter Notebookはどちらもインタラクティブなデータサイエンスのノートブック環境ですが、その設計思想と機能には大きな違いがあります。特に、**実行モデル**と**UIの構築方法**が異なります。

    以下に主要な機能比較をまとめました。

    | 機能/特性         | Jupyter Notebook                                   | Marimo                                             |
    | :---------------- | :------------------------------------------------- | :------------------------------------------------- |
    | **実行モデル**    | **線形、明示的実行**                               | **リアクティブ、自動実行**                         |
    |                   | - セルは上から下へ順に実行される                   | - 変数の依存関係に基づいて自動的に再実行される     |
    |                   | - ユーザーがセルを明示的に実行する必要がある       | - 変更があった変数に依存するセルのみが再実行される |
    | **状態管理**      | **グローバルで可変**                               | **リアクティブで明確**                             |
    |                   | - 実行順序によって状態が変化し、"隠れた状態"が発生しやすい | - 変数の再定義は不可。依存関係が明確で、再現性が高い |
    |                   | - ノートブックの再現性が低い場合がある             | - 常に最新のデータで実行されるため、再現性が高い   |
    | **UI/インタラクティブ性** | `ipywidgets`を使用                                 | `mo.ui`モジュールを使用                            |
    |                   | - ウィジェットの変更を処理するために明示的なコールバック関数が必要 | - UI要素は本質的にリアクティブで、コールバック不要 |
    |                   | - UIとロジックの結合が複雑になりがち               | - UI要素の値が変更されると、依存するセルが自動更新 |
    | **レイアウト/ダッシュボード** | 基本的な線形レイアウト。ダッシュボードにはVoilaなどの外部ツールが必要 | **組み込みのレイアウト機能**                       |
    |                   | - `HBox`, `VBox`などで簡易的な配置は可能           | - `mo.hstack()`, `mo.vstack()`, `mo.tabs()`などで複雑なレイアウトを簡単に構築可能 |
    | **ファイル形式**  | `.ipynb` (JSON形式)                                | `.py` (標準Pythonスクリプト)                       |
    | **バージョン管理**| JSON形式のため、Gitでの差分比較が難しい            | 標準Pythonファイルのため、Gitでの差分比較が容易    |
    | **デバッグ**      | 標準的なPythonのデバッグ手法                       | リアクティブな性質上、デバッグの考え方が異なる場合があるが、状態は明確 |
    | **エラー処理**    | エラーが発生したセルで実行が停止する               | エラーが依存関係を介して伝播し、問題の発生源が示される |
    | **学習曲線**      | シンプルなスクリプトには低い                       | リアクティブな概念を理解するのに少し時間がかかるが、UI構築は直感的 |
    | **エコシステム/成熟度** | 非常に成熟しており、広範なライブラリとコミュニティ | 比較的新しく、成長中                               |
    | **用途**          | - 探索的データ分析                                 | - インタラクティブなデータアプリケーションの構築   |
    |                   | - データサイエンスのプロトタイピング               | - ダッシュボードやレポートの作成                   |
    |                   | - 教育、プレゼンテーション                         | - 再現性の高い分析パイプライン                     |

    ### 主な違いの要約

    1.  **実行モデル**:
        *   **Jupyter**: 「レシピ」のように、書かれた順序でセルを実行します。途中のセルをスキップしたり、何度も実行したりすると、ノートブックの状態が複雑になり、再現性が損なわれることがあります。
        *   **Marimo**: 「スプレッドシート」のように、変数の依存関係を自動的に追跡し、変更があった部分だけを再計算します。これにより、常に一貫した状態が保たれ、再現性が非常に高くなります。

    2.  **UIとインタラクティブ性**:
        *   **Jupyter**: `ipywidgets`を使ってUIを作成できますが、UI要素の変更をPythonコードに反映させるためには、明示的なコールバック関数を記述する必要があります。
        *   **Marimo**: `mo.ui`モジュールで提供されるUI要素は、それ自体がリアクティブです。UI要素の値が変更されると、その値に依存するすべてのセルが自動的に再実行されるため、コールバックの記述が不要で、より直感的にインタラクティブなアプリケーションを構築できます。

    3.  **ファイル形式とバージョン管理**:
        *   **Jupyter**: `.ipynb`ファイルはJSON形式であり、コードだけでなく実行結果やメタデータも含まれるため、Gitなどのバージョン管理システムでの差分比較が困難です。
        *   **Marimo**: `.py`ファイルとして保存されるため、通常のPythonスクリプトと同様にGitで簡単に差分を追跡し、共同作業がしやすくなっています。

    ### どちらを選ぶべきか？

    *   **Jupyter Notebook**は、**探索的なデータ分析**、**線形なストーリーテリング**、または**既存の広範なエコシステム**を活用したい場合に適しています。
    *   **Marimo**は、**インタラクティブなデータアプリケーション**、**ダッシュボード**、**再現性の高い分析レポート**を構築したい場合、または**クリーンなコードベースでバージョン管理を容易にしたい**場合に非常に強力な選択肢となります。

    Marimoは、Jupyterの「ノートブック」としての利便性を保ちつつ、より堅牢で再現性の高い「アプリケーション」を構築するための新しいアプローチを提供します。
    """
    )
    return


if __name__ == "__main__":
    app.run()
